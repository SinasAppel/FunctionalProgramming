distinctPowers :: Int -> Int -> Int
-- Insert your own code here.
-- Generate the powersList for the arguments, use foldr and mergeLists
-- to merge them and then take the length of the resulting list.
distinctPowers m n = length (foldr mergeLists [] (powersList m n))

-- powersList takes two integers and generates a list of lists of 
-- length n-1 (to represent [2..n]) containing the powers of [2..m]
powersList :: Int -> Int -> [[Integer]]
powersList m n = [ take (n-1) (powers a) | a <- [2..m] ]

-- powers generates the infinite list of powers of its argument.
powers :: Int -> [Integer]
powers a = [ (fromIntegral a)^b | b <- [2..] ]

-- mergeLists looks at the first elements of its arguments and puts the 
-- smallest one at the front of a list generated by a recursive call
-- minus that element.
mergeLists :: Ord a => [a] -> [a] -> [a]
mergeLists [] ys = ys
mergeLists xs [] = xs
mergeLists (x:xs) (y:ys) 
  | x < y = x : (mergeLists xs (y:ys))
  | y < x = y : (mergeLists (x:xs) ys)
  | otherwise = x : (mergeLists xs ys)

-- Do not change the following wrapper code
wrapper :: [String] -> Int
wrapper (a:b:_) = distinctPowers (read a::Int) (read b::Int)

main =  print . wrapper . words =<< getLine
